# Kermit the Timer

Welcome to [Kermit the Timer](https://kermit-the-frog-vercel.vercel.app/)! Our site serves as a user-friendly Rubik's Cube competitive timer that cubers can use to train for their next event. Our site comes with an account system where users can log in using a username and password, or through their Google or GitHub accounts. Within the timer interface, users can create unique sessions which can be used to track time data for different training sessions or even different cube configurations. If using a 3x3 cube, user's can even choose to have tournament-legal scrambles generated for them, and can generate new ones easily if they do not like the provided one. To start the timer, user's simply press and hold the spacebar until they are ready to begin, and press it again to stop it. The combined timer and scramble data (known as a solve) is saved on the left side of the screen in a sidebar that also holds the current session, the user's best session time, and their best "average of five" time. Each solve contains a dropdown that allows users to modify its data based on the result of their attempt including Did Not Finish (DNF), finishing one move away (+2), or resetting the state all together (OK). Additionally, user's can see the generated scramble for the selected solve, and delete the solve from their saved session data. Finally, user's can record their solve sessions by selecting the toggle in the bottom right to enable video mode. Once in video mode, user's can start the timer and their camera will begin recording a video. After stopping the timer, the user will be prompted to download the recording of their solve. User's can also access a data visualization page where they can view interesting stats about each session's solve times. Our data visualization shows a trend line of their individual, average of five, and average of twelve times, a histogram of solve times, and a smoothed density plot to display the distribution of solve times.

As our site uses free hosting sites to support our backend scramble API, user's will most likely experience up to a minute of lag when generating their first scramble while they wait for the site to start up. To combat this, user's may wish to visit [the site](https://scrambler-api-s5qg.onrender.com/getScramble) before starting our application so that the back-end website starts up faster and they can view when it is complete. This is simply a "we're not paying for a server that is always on" problem and not an implementation problem, so we apologize for the inconvenience. Our API's Docker Repo can be found [here](https://hub.docker.com/r/cgolding8/scrambler_api).


## Tech Stack
- **Web Framework:** NextJS
- **Authorization:** NextAuth (and configured OAuth providers)
- **Database Back End:** MongoDB
- **API Back End:** Spring Boot (Java)
- **UI Framework:** Tailwind CSS
- **Data Visualization Package:** D3.js


## Challenges
1. **Rubik's Scrambler API** - One challenge we faced when creating our website was trying to figure out how to generate a scramble, and do it fast. After a lot of research, we found an online repository containing code for a UI-based software app to solve Rubik's Cubes. we extracted the back-end code used in the scrambling of the cube, modified the output, and then attached it to a Spring Boot project. This proved difficult as we had never worked with Spring Boot before, and it was quite finicky to work with. Additionally, implementing Cross-Origin Resource Sharing (CORS) for the back-end so that only certain sites could request data from the website also proved a pain. After getting it all packaged into a .jar file and creating a Docker Image though, we were able to host it on Render and begin making get requests to the server.
2. **Video Recording** - Looking to add more helpful features to our website, we decided on adding a video recording service which ended up presenting several technical challenges. One difficult aspect was managing the exact timing of recording initialization and synchronization with the cube timer. The recording must start when the timer enters its "ready" state, to avoid cutting off the beginning of the solve, which would make the video useless. To achieve that, it was necessary to be careful with state management between systems. Another challenge was handling browser compatibility across platforms. A solution we found was a MIME type detection system that progressively tests for video format support. Finally, we needed to prevent memory leaks and performance degradation. This required a robust resource cleanup procedure for both successful and failed recording attempts, as camera streams and media recorder instances can continue consuming significant resources if not properly terminated, especially if the user quickly abandons solves due to bad starts, making rapid timer resets.
3. **Data Visualization UI** - Another challenging aspect of our project was making it not only user friendly, but also useful. When designing the data visualization aspect of our site, we encountered problems while dynamically scaling points on the plot after zoom in/out. This was quite difficult as there was very little that could be done with traditional debuggers so important information needed to be logged to the console in order to compare it with the displayed information.
4. **OAuth Implementation** - Another challenge we faced while building our website was related to the implementation of OAuth third-party authentication. The registration of the apps (especially with Google) for our local testing and deployment proved time consuming due to the extremely complex documentation and lack of examples. Additionally, attempting to take advantage of the token information provided from the third-party response to add the user to our database was quite difficult as our state variables often returned incorrect information and it was hard to troubleshoot due to the asynchronousness of the state variables. Making sure that the correct redirects were made, and that the data was passed and validated correctly, and continued to persist during the life of the user session, made this part of implementation particularly taxing.
5. **Asynchronous Variables and MongoDB Compatibility** - Finally, a challenge we all encountered was managing state variables across our website. This proved particularly relevant when developing the timer due to their asynchronous nature and the need for exactness when building the heart of our site functionality. To address this, we used simple variables to supplement and support our state variable usage, allowing for more accurate solve timing. Additionally, as this was many of our first times working with NextJS and MongoDB, we often struggled with syntactical and structural errors that these various interfaces required from us. To combat this, we collaborated often over one-on-one and group calls to collaboratively fix persistent bugs and other issues. Our team worked extremely well together, and we were able to help each other out using each of our own particular sets of expertise.

## Contributions
- **Cole** - Found and modified a pre-existing UI-based Rubik's Cube solver to extract just the back-end capabilities. Built an API using Java Spring Boot to build the program and return a valid solved scramble when called. Hosted and maintained the API server using Render's deployment and logging systems. Built the scramble display banner and various "new scramble" callers, and added scrambles to the database's backend. Fixed the sidebar front-end display and setup, and assisted in beautifying the site. Wrote the README and compiled groupmates responses for contributions / challenges.

- **Gleb** - Served as the Scrum Master and ran daily in-class scrum meetings and weekly overview meetings. Added theme functionality that allows users to choose between three themes that dynamically change the application's color scheme. Created a reactive header with appropriate navigation links for each page that contains a logo (which acts as a home button) and theme selector dropdown. Additionally, created a video recording system which captures cube-solving sessions (or other timed activities) directly within the browser. Built in handling for browser camera permissions and created an optional download pop-up after a user has ends the timer. Finally, strengthened error prevention for the user by dynamically choosing between MP4 and WebM file formats depending on the user's system capabilities.

- **Kelu** - Implemented three visualizations: Trend Analysis (displays solve times with the option to switch between time-based and index-based views), Time Distribution (shows the frequency of solve times across different ranges), and Solve Density (provides a smoothed density plot for visualizing the distribution of solve times). Gave users the ability to adjust the detailing or smoothing level and trimming or range adjustments to refine the view of Solve Density. Provided support for multiple data types, including single solve times, Averages of 5 (Ao5), and Averages of 12 (Ao12). Added dynamic data filtering based on the selected session, which will allow users to explore different solving sessions separately. Finally, provided a number of interactive visualization tools including zoom in/out (using scroll), pan (click & drag), autoscale (double-click), and tooltips (hovering over a point).

- **Marco** - Refactored the entire base project to follow React's recommended best practices and to take advantage of their built-in responsive home pages. Implemented and configured Google and GitHub OAuth login functionalities and expanded the initial nextAuth credential provider. Updated the login and registration pages to follow the provided style guides and to include the appropriate redirects, requests, and graceful error handlings expected of a login/registration page. Implemented the "sessions" functionality including providing the user with two default sessions (3x3 and 5x5). Additionally, added the ability for users to create their own custom sessions through a pop-up. Finally, created and maintained the database's structure and usage methods, and streamlined the access and control points for each collection.

- **Tim** - Served as the Product Owner and leveraged my knowledge of the Rubik’s Cube community to guide the project in the right direction and create use cases for our product to fulfill. Developed the initial implementation of the project for Assignment A4, including the timer functionality to simulate a real [Rubik’s Cube StackMat Timer](https://www.speedstacks.com/store/retail/speed-stacks-g5-timer/?srsltid=AfmBOoq1aNEFsbIn3t_fpw8ht_baX46tFT05ZhMqCFgA7wqLwg9Kv5DN). Set up all initial NextAuth credential and data HTTP requests and database calls, and maintained them throughout the implementation process of the project. Transitioned old data structures to updated database "session" objects to hold more varied information. Implemented helper functions to calculate the Average of 5 (Ao5), Best Solve, and Best Ao5. Displayed these computed values in a sidebar with dropdowns that allowed for modification of the state of the solve. Finally, added session switching, allowing users to toggle between different puzzle and attempt types.


A video overview of our website can be found [here](https://www.youtube.com/watch?v=UcQEq3xQn70). A sped up version (under 5 minutes) can be found [here](https://www.youtube.com/watch?v=DhKkRC2uL2E).